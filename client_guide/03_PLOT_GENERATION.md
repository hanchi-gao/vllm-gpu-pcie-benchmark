# 性能圖表說明文件

本文件說明 vLLM 性能測試系統提供的 4 種圖表類型及其解讀方式。

---

## 📊 圖表總覽

| 圖表名稱 | 文件名 | 測試類型 | 主要用途 |
|---------|--------|---------|---------|
| 綜合性能報告 | `benchmark_comprehensive.png` | Production | 全面性能分析（3 個子圖） |
| 標準化性能報告 | `benchmark_normalized.png` | Production | 不同配置相對性能比較 |
| 擴展性報告 (1-1000) | `scaling_benchmark.png` | Scaling | 高負載擴展能力分析 |
| 擴展性報告 (1-200) | `scaling_benchmark_200.png` | Scaling | 低中負載詳細分析 |

---

## 1️⃣ 綜合性能報告

**文件**: `benchmark_comprehensive.png`
**適用測試**: Production Benchmark
**圖表結構**: 3 個水平排列的子圖

### 子圖 1: Output Throughput vs Context Length

**指標**: 輸出吞吐量（Output Throughput）
**單位**: tokens/sec

**軸說明**:
- **X 軸**: Context Length (K tokens) - 輸入長度
  - 範圍: 1K, 2K, 4K, 8K, 10K, 32K, 64K, 96K
- **Y 軸**: Throughput (tokens/sec) - 每秒生成的 token 數
- **曲線**: 每條線代表一個並發數 (1, 2, 5, 10, 20 users)

**解讀要點**:
- ✅ **越高越好** - 吞吐量越高，系統處理能力越強
- 📈 **趨勢觀察** - 隨輸入長度增加，吞吐量通常下降
- 🎯 **最佳點** - 找出吞吐量最高的並發數和輸入長度組合
- ⚠️ **性能下降** - 如果某配置吞吐量急劇下降，可能存在瓶頸

**典型模式**:
- **高並發 + 短輸入** → 高吞吐量
- **低並發 + 長輸入** → 低吞吐量
- **中等配置** → 平衡點

---

### 子圖 2: Time To First Token (TTFT) vs Context Length

**指標**: 首 Token 時間（TTFT）
**單位**: 秒 (s)

**軸說明**:
- **X 軸**: Context Length (K tokens) - 輸入長度
- **Y 軸**: TTFT (s) - 從發送請求到收到第一個 token 的時間
- **曲線**: 每條線代表一個並發數

**解讀要點**:
- ✅ **越低越好** - TTFT 越低，用戶感知的響應速度越快
- 📊 **基準值**:
  - < 0.5s：優秀
  - 0.5-2s：良好
  - 2-10s：可接受
  - \> 10s：需要優化
- 📈 **趨勢**:
  - 隨輸入長度增加而上升（需要處理更多 token）
  - 隨並發數增加而上升（排隊等待時間）
- ⚠️ **警告信號**: TTFT 急劇上升表示系統過載

**影響因素**:
- 輸入長度（Prefill 階段耗時）
- 並發請求數（排隊等待）
- GPU 計算能力

---

### 子圖 3: Time Per Output Token (TPOT) vs Context Length

**指標**: 每 Token 生成時間（TPOT）
**單位**: 毫秒 (ms)

**軸說明**:
- **X 軸**: Context Length (K tokens) - 輸入長度
- **Y 軸**: TPOT (ms) - 生成每個輸出 token 的平均時間
- **曲線**: 每條線代表一個並發數

**解讀要點**:
- ✅ **越低越好** - TPOT 越低，token 生成速度越快
- 📊 **基準值**:
  - < 10ms：優秀（高速生成）
  - 10-20ms：良好
  - 20-50ms：可接受
  - \> 50ms：需要優化
- 📈 **穩定性**: TPOT 應該相對穩定，不隨輸入長度大幅變化
- ⚠️ **異常**: 波動大或持續上升表示系統不穩定

**影響因素**:
- KV Cache 大小（輸入越長，cache 越大）
- GPU 記憶體頻寬
- 批次處理效率

---

## 2️⃣ 標準化性能報告

**文件**: `benchmark_normalized.png`
**適用測試**: Production Benchmark
**圖表結構**: 3 個水平排列的子圖

### 子圖 1: Total Token Throughput vs Number of Requests

**指標**: 總 Token 吞吐量
**單位**: tokens/sec

**軸說明**:
- **X 軸**: Number of Prompts - 並發請求數 (1, 2, 5, 10, 20)
- **Y 軸**: Total Token Throughput - 總吞吐量
- **曲線**: 每條線代表一個輸入長度 (1K, 2K, 4K, 8K, 10K, 32K, 64K, 96K)

**解讀要點**:
- 📈 **理想趨勢**: 隨並發數增加而上升，最終達到平台期
- 🎯 **飽和點**: 曲線開始平緩的位置，表示最大處理能力
- 📊 **比較**: 不同輸入長度在相同並發下的性能差異

---

### 子圖 2: Output Throughput per Request vs Number of Requests

**指標**: 每請求輸出吞吐量（標準化）
**單位**: tokens/sec/request

**軸說明**:
- **X 軸**: Number of Prompts - 並發請求數
- **Y 軸**: Output Throughput per Request - 標準化吞吐量
- **曲線**: 每條線代表一個輸入長度

**解讀要點**:
- 📉 **預期趨勢**: 隨並發數增加而下降（資源競爭）
- 📊 **效率指標**: 每個請求的平均處理效率
- 🎯 **最佳點**: 找出效率與並發的平衡點

---

### 子圖 3: Mean TTFT vs Number of Requests

**指標**: 平均首 Token 時間
**單位**: ms

**軸說明**:
- **X 軸**: Number of Prompts - 並發請求數
- **Y 軸**: Mean TTFT - 平均 TTFT
- **曲線**: 每條線代表一個輸入長度

**解讀要點**:
- 📈 **預期趨勢**: 隨並發數增加而上升（排隊時間）
- ⚠️ **陡峭上升**: 表示系統接近飽和
- 📊 **輸入長度影響**: 長輸入的 TTFT 通常更高

---

## 3️⃣ 擴展性報告 (1-1000)

**文件**: `scaling_benchmark.png`
**適用測試**: Scaling Benchmark
**測試配置**: 輸入 1K tokens，輸出 128 tokens

### 圖表結構

**軸說明**:
- **X 軸**: Number of Requests - 請求數量 (1 到 1000)
- **Y 軸**: Throughput (tokens/sec) - 吞吐量
- **曲線**: 單一曲線，展示吞吐量隨請求數變化

### 解讀要點

**理想曲線形狀**:
```
吞吐量
  ↑
  │     ┌────────  (3) 平台期
  │    ╱
  │   ╱           (2) 過渡區
  │  ╱
  │ ╱             (1) 線性增長區
  └─────────────→ 請求數
```

**三個階段**:

1. **線性增長區 (1-100)**:
   - 吞吐量線性增加
   - 系統未飽和，資源充足
   - 每增加請求，吞吐量穩定提升

2. **過渡區 (100-500)**:
   - 增長速度減緩
   - 系統逐漸接近瓶頸
   - 資源競爭開始顯現

3. **平台期 (500-1000)**:
   - 吞吐量趨於穩定
   - 達到系統最大處理能力
   - 此處的 Y 軸值即為**最大吞吐量**

**關鍵指標**:
- 📊 **最大吞吐量**: 平台期的 Y 軸值（系統峰值性能）
- 🎯 **飽和點**: 曲線開始平緩的 X 軸值（最大並發承載）
- 📈 **線性區間**: 保持線性增長的請求數範圍（最佳工作區）

**異常模式**:
- ⚠️ **早期平台化** (< 100 requests): 系統瓶頸，需要優化
- ⚠️ **波動曲線**: 系統不穩定
- ⚠️ **下降趨勢**: 嚴重性能問題

---

## 4️⃣ 擴展性報告 (1-200)

**文件**: `scaling_benchmark_200.png`
**適用測試**: Scaling Benchmark (詳細版)
**測試配置**: 輸入 1K tokens，輸出 128 tokens

### 圖表結構

**軸說明**:
- **X 軸**: Number of Requests - 請求數量 (1 到 200，密集採樣)
- **Y 軸**: Throughput (tokens/sec) - 吞吐量
- **曲線**: 單一曲線，更細緻的採樣點

### 與 1-1000 報告的差異

| 特性 | 1-200 報告 | 1-1000 報告 |
|------|-----------|------------|
| **範圍** | 1-200 | 1-1000 |
| **採樣密度** | 高（每點） | 中（1-200 每點，200-1000 每 50 點） |
| **用途** | 低中負載詳細分析 | 全範圍擴展能力 |
| **適合場景** | 找出最佳並發數 | 了解極限性能 |

### 解讀要點

**詳細觀察**:
- 🔍 **精細變化**: 可以看到 1-200 範圍內的細微性能變化
- 🎯 **最佳並發**: 更容易識別吞吐量峰值點
- 📊 **早期飽和**: 如果在 200 以內就達到平台期，表示系統負載能力有限

**典型應用**:
- 確定生產環境的最佳並發配置
- 識別性能突變點
- 分析小規模負載特性

---

## 📐 圖表通用元素說明

### 圖例 (Legend)

**位置**: 通常在右上角或左上角
**內容**:
- 綜合報告: "Concurrent Users" (1, 2, 5, 10, 20 users)
- 標準化報告: "Context Length" (1K, 2K, 4K, ..., 96K)
- 擴展性報告: 無圖例（單一曲線）

**顏色編碼**:
- 🔵 藍色: 1 users / 1K
- 🟣 紫色: 2 users / 2K
- 🟠 橘色: 5 users / 4K
- 🔴 紅色: 10 users / 8K
- 🟢 綠色: 20 users / 10K

### 網格線 (Grid)

- 淺灰色虛線，方便讀取數值
- Alpha 透明度 0.3，不干擾數據

### 標記點 (Markers)

- 子圖 1: ● 圓形 (Throughput)
- 子圖 2: ■ 方形 (TTFT)
- 子圖 3: ▲ 三角形 (TPOT)

---

## 🎯 性能分析建議

### 1. 先看綜合報告
- 全面了解系統在不同配置下的表現
- 識別主要瓶頸（吞吐量 vs TTFT vs TPOT）
- 找出最佳配置組合

### 2. 再看標準化報告
- 比較不同輸入長度的相對性能
- 了解並發數的影響
- 找出效率最高的配置

### 3. 最後看擴展性報告
- 了解系統的極限承載能力
- 確定最大吞吐量
- 評估是否滿足業務需求

### 4. 對比分析
將 1-200 和 1-1000 報告對比：
- 驗證性能趨勢一致性
- 確認飽和點位置
- 規劃容量擴展策略

---

## 📊 圖表文件位置

所有圖表保存在專案根目錄下：

```
/home/user/vllm_t/output_plots/
├── benchmark_comprehensive.png      # 綜合性能報告
├── benchmark_normalized.png         # 標準化性能報告
├── scaling_benchmark.png            # 擴展性報告 (1-1000)
└── scaling_benchmark_200.png        # 擴展性報告 (1-200)
```

**圖表規格**:
- 格式: PNG
- 解析度: 300 DPI（高清晰度）
- 尺寸:
  - 綜合/標準化報告: 24" × 7"（水平三聯圖）
  - 擴展性報告: 單圖（自適應）

---

## 💡 關鍵性能指標 (KPI) 提取

### 從綜合報告提取

| KPI | 位置 | 最佳值 |
|-----|------|--------|
| 最大吞吐量 | 子圖 1，曲線峰值 | 越高越好 |
| 最低 TTFT | 子圖 2，曲線最低點 | < 100ms |
| 穩定 TPOT | 子圖 3，曲線平均值 | < 20ms |

### 從擴展性報告提取

| KPI | 位置 | 說明 |
|-----|------|------|
| 峰值吞吐量 | 平台期 Y 軸值 | 系統最大處理能力 |
| 飽和點 | 平台期起始 X 軸值 | 最大並發承載 |
| 線性範圍 | 線性區間 X 軸範圍 | 最佳工作負載區間 |

---

**報告解讀完成後，建議將關鍵發現記錄在性能評估報告中。**
